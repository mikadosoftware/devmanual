==================
The DevManual
==================

RoadMap
=======

the devmanual is about everything 
needed for a software team to operate 
within a business or organisation,
everything *before* a line of code 
is written - the stuff every team 
needs or will benefit from, from 
CI/CD setup, review processes, etc


This is a book about filling in the missing gaps on how to 
be part of, setup, maintain, run, "self-manage" a software team / teams.
Its not about what programming language, its about how to deal with users, 
auditors, maangers, what is best practise and what is just theatre.

It flows from one point of view - the code is *everything*.

The goal is to identify a *gross* (144) of concepts that are important to
software development teams and running a software service, in-house, or
commerical.

The goal is to start at smallest level, fully controlled, and then expand as
needed - going from 0 to around 10,000 machines/instances.

My motivation is being fed up over the years that while I *know* this stuff, if
I am dropped into a new environment, I focus on the most important hair on fire
stuff, but that looks like I am ignoring the rest.  And someone inevitably comes
along and says "hey, we should do ticketing like this or containers like that"
and we lose the map like overview.

So this is my, "trust me, I know what I am doing" book.

Everything is a feedback loop.
------------------------------
Everything is a feedback loop.  Everything feeds into something, and at the very
minimum it feeds into the MIS (the summarisation tool that your "level" reports
into.).  THis is an important (to me) concept - build an MIS tool that is what
you think your manager should be seeing (obligatory BOb Dylan quote - everybody
serves somebody).  That might not be how the actual manager sees or wants to be
shown but it is something you can control and adjust.

So we need at least 144 feedback loops, and 144 metrics (at least) in our MIS
dashboard.  Which will be built in chapter X.


A friend who was a photographer would explain
hownhe overcame his "imposter syndrome".
He has enormous amounts of "kit" (gear might be more photogenic)
but he just keeps one simple camera withbone lens
in thebcar - because he is capable of doing the big setup annie leobowotz stuff 
but he chooses simplicity most of thebtime

The devmanual is about simplicity as choice in being a software developer

this is not the guide to witing small bits of code aa a single developer

its a guide to writing large bodies of code as part of a larger 
usually corporate team(s)

throughout my career I have started or joined teams of people with a usually xorporate goal inmmind

often we thought we needed lots of kit - downloadongnhadoop and datalake setups
and this does matter - but its like lenses for my photogroaher friend - you can fo anhellmof anlong way with 
awk and cat and a but of thinking.

team started talking like a team

when we start talking like a team, when we have operations sorted
its all part of the same thing

its a devmanual - as simple as we can



Deployment
-----------

We will be using docker like VMs, cos its simple. NIX will follow on.
And these dockers will end up being hosted in OpenShift. 

We assume that we are *not* cloud first.  I know I know.
We are going the homelab route - the core of what we sahll start with will sit
on a desk next to us - because cloud is not all.
one laptop, one server, then cloud, can be expa nded into more people and
more offices.

but things like gvisor are sensible


top level concerns
------------------

* CI / CD
** Jenkins
** githubflow, gitgitflow, gitflow.  Tagging vs labels vs whats in which env
** unit testing, test at IO boundaries, 
** coverage
** whole org test rig
** linting
** static analysis
** artifact mgmt
** monorepo vs microrepo
** build testing
** secrets (see vault etc)
** failfast,
** share deployment chunks - ie teams share jenkins snippets
** single server to start ocnceptually - salt or ansible or terraform or whatever.
** docker / containerisation (leading to Nix)
** environment consistency
** metrics and reporting


* Infrastructure as code
** containers and orchestration
** DNS
** TLS, CA, Certs, 
** HA / DR / Horizontal scaling, caches
** build complete stack from scratch in docker
** API gateways, loadbalancing, quotas etc
** dont use kebernetes - or rather. Have your own deplyment process, that knows the names of servers. 
** chaosmonkey - have failback server names, cattle still have distinct identities, (cattle not pets, not same as virtual abstracts not pets)
** Homelab - https://linuxblog.io/home-lab-beginners-guide-hardware/ - 
** one laptop, one server, then cloud, can be expa nded into more people and
more offices.
** SRE work and theory
theory we need is 1. five whys analysis, blame free
2. process control theory 3. 
https://news.ycombinator.com/item?id=42584750

* monitoring and observability
** grafana
** openTelemetry
** reporting, 
** pagerduty
** QA and testing as part of this
** logging and centralised logging and log monitoring and scanning
** business event capturing
** combine Nasa OpenMCT and OpenTelemetry
   Telemetry is everything in moving from IRL to Virtual.
   Telemetry of security swipes, logins, purcahses etc etc.
   simple data management - who owns the names under each layer of dots.
   company.site.greenfieldhouse.5thfloor.lights.powerusage
** see cloudflare use of open telemetry to return logging
use single otel collector on server instance for all monitoing 
** logging

* SDLC 
** DORA metrics
What is difference between software coding and softeware engineering?
Metrics (Dave Farley)
Produce Better software Faster.
DORA has a clear statement "Stability & Speed" which is measureable with 
My only objection is that it still assumes *tickets drive Development* whereas I think
most software is really increasing capability aligned to mission, 
and suddenly discovering a leap forward.
Keep doing software and use the DORA metrics to show that you are going off track.
Too much focus is on how can managers control (improve?) the software development process
whereas they dont have the right levers *as managers*. They can only improve the other things
that stop people being amazingly productive.  
We can tell they are amazingly productive with the Dora metrics.
If those metrics fall, we change things 

Things that are likely to effect it 

Psycholigical safety
Clear congruent goals
Strong engineering platforms and good dev leads and good communication
strong mission and sense of shared responsibity and reward
psycholiogccal safety
people management 
dumb mistakes happen to smart people too

We dont measure *individual developer productivity* (beyond basic competance)
because thats not the key - the key is increasing the capability of the whole organisation.
An Army of Rambos pretty soon stops having artillery or airplanes and boats.

How do we measure capability of whole org? WHole org test rigs seems a good idea!


** git rebase
** tickets, JIRAS, tracking and reporting time
** punchclock
** discussions around code not ideas - one paragraph is enough to start
** linting
** static analysis https://github.com/PyCQA/bandit
** isort
** explore vs exploit. Never be in position where the quick docs fix takes less
time than the tickets and commits etc.  How to include small valuable fixes? 

* Security and IAM
** Certs, client certs,
** TLS is not good enough - chanell is not per request authentication
** appsec -> shehackspurple 
** FIDO webauthn
** 

https://medium.com/cryptomove/moving-target-defense-recent-trends-253ce784a680
MovingTargetDefence - this is lessons from WWI and tier one armies
https://eprint.iacr.org/2016/741.pdf
https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html

Design thoughts
use CA to generate client cert.
use orchestration deployment tools to gove app instance that client cert
have app pull into memory (store in protected memory - https://www.rapidinnovation.io/post/rusts-memory-management-and-ownership-model)
then can use client cert to request other secrets

open source vault - https://www.pulumi.com/docs/



* Software Governance, Compliance, Democracy
** Trolley problem


* Management Information Systems, project mgmt, risk mgmt, planning, budgets
** MIS is not for managers.
** Risk mgmt is all, keep a risk log before a gantt chart
Risk mgmt is like DORA metrics - 
you probably cannot plan but you can tell if you are getting warmer.
The planning fallacy
** Dashboards out of observability
** Management is the place for statisical process control.
If we can repalce management with a perl script,
 are we looking at disaggremation of managemenet.

** one level up, 2(O) 100x bigger
** is there a max number of chnages one can make per day?
https://news.ycombinator.com/item?id=42487663
** Twitter - can you really fire 90% of the devs?
What about all the other things that hurt at scale
3-4(O)

I often find project managers and senior management wanting a “zipper” project - where some big brained architect predicts the future use cases and needs and can plan pulling together the teeth in 15 steps ahead

Which is of course rubbish - mostly it’s amazing if you can predict the next zip.

this is "next step or phase soace" projeft mgmt - what you can do next is defined by your previous choices - so improce optionality - make tools and platforms not topless or low code decisions 


Things shoukd be as simple as possiblenbutnnonsimpler
	

simplicity as a choice

A business is simply a collection of processes made against inputs usong capital (texhnology)
Its unlikely that any business on thenplanet has a complete accurate (ie automated)
listing of its proceses - and absolutely nonw that have auplliers with same

getting there seems a good idea 

Microsoft has a thing called "capture??" lots of companies AI startups are
teting to allow compmies to find out just wtf they actually do all
day


* SLAs, Operations, Incident Mgmt
** SLAs SLOs - the SRE problem
** runbooks, autoamtion, how 
** Statistical Process Control in Operations
https://en.wikipedia.org/wiki/Statistical_process_control
** AI analysis of operations
HolmesGPT - AI that can try to knit together different parts of failing
errors and provide easier root cause analysis.  sorta LLMs to check error
codes.https://news.ycombinator.com/item?id=41326039

* Testing and QA - a spectrum
** unittesting
** fuzzing
** at some point everything that can be auotamted out of the way should be done before you think.
** Whole Org Test rig

* Disaster recovery and Backup
** see 'build everything from scratch in docker on demand'

* COnfiguration Mgmt, feature toggles and release mgmt
** etcd, what does "release to production" mean with toggles and config?
** a given config should be hashable so we have code hash plus config hash as stable 


* documentation
** have osme
* finance 
https://www.ycombinator.com/documents/


Measuring productivity
-------
https://news.ycombinator.com/item?id=40272186
Its hard. software is a creative acticity
even if the software is going to be used as a machine 
the building of a factory assembly line is 
front loaded into the factory cost. yet it is the most vital part of a factory
yet software is design a aseembly line everything





