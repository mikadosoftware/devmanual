====
mind
====

Technical Capabilities
======================


* Measure Lines Spent
  Edgar Djyskstra quote - tech debt
  The more code written the more there is to understand
  Writing lots of code, writing it quickly, is often the contractor curse - too much too soon. There is no such thing as hitting the ground running.

* measure Onboarding times

* measure code quality not feature velocity

* measure effort to deploy

* measure inter dependancy

* measure metrics - is code well
Measured in production

* web logging good enough practise

- generate a unique ID per request, pass it through all stages

amatix 2 hours ago [-]

For us, a `X-Request-ID` header is generated by any app if it doesn't receive it from upstream -- but normally nginx or the CDN will generate it. There's a few nginx modules to do it, we use https://github.com/newobj/nginx-x-rid-header
Most languages/logging frameworks have some sort of per-thread context (eg. Filters in Python, MDC in log4j, etc) to be able to tag log messages with. If you're using postgresql, you can call `SET application_name='{requestID}';` and that can be output as part of logs too.
reply


* Deployment can deploy code through promotion of fixed "builds" into
  production using totally automated means.

* micro services architecture This is a major issue. Includes
  security, service discovery messaging logging and pr nose to only go
  through front door. See stevey blog post.
  https://news.ycombinator.com/item?id=12133670
  Use fluentd logging
https://blog.treasuredata.com/blog/2016/08/03/distributed-logging-architecture-in-the-container-era/

* OS installation and Hardening Choice of OS, location Ansible or
  similar automation scripts

* Kerberos and Authentication Authentication and Authorisation are
  vital capabilities and federated, distributed security have so many
  advantages (think uUId as primary key )

* Build promotion and use of containers PyHolodeck

* message queues and worker pools Messaging Job scheduling based on
  events and then queues Is a resource problem always

* performance monitoring metrics gathering with graphite

* unit testing, integration testing, perfromance testing

* user acceptanbce tests and UI tests Automated testing is vital and
  we must put huge amounts of effort into it simply to make the next
  release

* continuous integrations and delivery There is no point batching up
  changes to go on a time based schedule. Code is ready as it is
  written and the decision to release should be based on automated
  tests. Only marketing or other business decisions should delay - so
  always push to pre-prod

* pre-prod is live-clone

* replaying actual traffic

* Reporting
  Simple reports

* SOPs and checklists

* Measuring metrics

* documentation

* Dev Ops

* statistics

* distributed data and computation
  Use of Apache spark, Hadoop etc

* Javascript

* Angular vs Jquery

* Programmable Corporation

* functional programming and scalability
  Elixr and OTP

* bug tracking, code analysis,

* git and git workflow

* Linux and workstations

* Mobile development

* Big Data

* Maturity and keeping on a single course

* seven league boots

* earthquake-let theory of software development. Building blocks not planned features

* Work harder on fewer projects and polish them to be CV-worthy shipping working software

* Message Queue

* Business Intelligence reporting

* Software KPIs, buisness KPIs

* Simple Marketing (Twilio approach), SEO
https://www.ducttapemarketing.com/blog/guide-to-small-business-keyword-research/


* Debugging tools
  CHarles proxy
  Chrome debugger

* Web technologies (html 5)
  Bootstrap, HTML 5, cimples CSS

* Rekational Databases

* NOSQL databases

* Storage systems

* Backup and recovery
  Business Disaster recovery and assurance
  Multiple data centres

* Time, Unicode, basic data types

* serialisation
  pickle, json etc

* Cacheing

* Configuration basics

* command line is all

* Publishing own work

* contact management

* email management

* Practise on smaller complete projects

* jenkins

* chatbots and IRC. Team comms. Choose one one o said one!!

* erlang

* rethinkdb

* training and just reading and exploring
if you do not explicitly make time to learn but sprint all the time all you will have is people who have learnt what they wrote
