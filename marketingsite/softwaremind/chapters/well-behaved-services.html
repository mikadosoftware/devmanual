

<!doctype html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Keeping micro-web services alive, supervised and restarted &#8212; TheDevManual 0.0.1 documentation</title>
    
    <link rel="stylesheet" href="../_static/devmanual.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/bizstyle.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="top" title="TheDevManual 0.0.1 documentation" href="../index.html" />
    <link rel="next" title="Using GitHub / ssh" href="using_github__ssh.html" />
    <link rel="prev" title="webtest" href="webtest.html" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <!--[if lt IE 9]>
    <script type="text/javascript" src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
  </head>
  <body role="document">

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="section" id="keeping-micro-web-services-alive-supervised-and-restarted">
<h1>Keeping micro-web services alive, supervised and restarted<a class="headerlink" href="#keeping-micro-web-services-alive-supervised-and-restarted" title="Permalink to this headline">¶</a></h1>
<p>Waiting around to restart your web server is painful - Steve Huffman, one of the
founders of Reddit talks about literally sleeping with his laptop next to his
bed and constantly waking to restart a process at ungodly hours of the morning.</p>
<p><a class="reference external" href="http://yobriefca.se/blog/2013/04/29/micro-service-architecture/">Micro-services</a> are in my
view a great way to arrange our business applications.  By splitting the work
done into smaller components, and having the work done by seperate webservers
running just a small piece of code, we find several benefits</p>
<ul class="simple">
<li>our code is better structured, because we cannot rely on the big framework to
pass bits around for us</li>
<li>Testing the service is easier</li>
<li>Things cen be upgrade, downgrade or side-ways-graded with more confidence.  A
fix to one tiny piece of independantly running code will hardly ever affect
the others.  In a monolithic application that is rarely true.  Change the font
size for Page X, ooops that just killed half the CSS on site.</li>
<li>naturally robust / redundant.</li>
</ul>
<p>And so...</p>
<p>Now imagine if he had built a micro-service architecture, 50 or more seperate
web servers, and was manully trying to watch them all, Reddit could have failed
and we would have lost millions of LoLCatz. The horror!</p>
<p>Eventually he discovered <cite>supervisord</cite> and got some sleep.  This is a Good
Thing.</p>
<p>We also want something that will monitor them and respawn them when they die.</p>
<p>This will we hope increase our chances of a service that is small, stays up and
if it fails, is automatically brought back up.</p>
<p>We also want to keep things simple.</p>
<div class="section" id="the-simplest-way-possible-to-keep-a-service-running">
<h2>The simplest way possible to keep a service running<a class="headerlink" href="#the-simplest-way-possible-to-keep-a-service-running" title="Permalink to this headline">¶</a></h2>
<p>It would be lovely to write a web service, set it running and
know that if it fell over, divided by zero, or otherwise went wrong
it would immediately be picked up, dusted down and restarted.</p>
<p>If we can do that so it scales upwards really well when it is working.</p>
<p>Oh and it needs to make the tea too.</p>
<p>Ok, the first part is <cite>process monitoring</cite> - watching a running process,
and if it falls over (or rather exits with non zero) restarting it.</p>
<p>There are a lot of options out there - <cite>supervisord</cite>, <cite>god</cite> are a couple that
spring to mind.  But these are inherently part of a language ecosystem (Pyhton
and Ruby respecitively).  This is not a <em>bad</em> thing, they do the job, but
distributions and sysadmins have for a long time faced these problems and come
up with effective solutions already.  I think this is part of the packaging
problem all language eco-systems seem to face - and often well solved by looking
at the distribution tools first and then worrying.</p>
<p>The SysV / init camp of tools is old, and still very effective.  Over the years
new olutions have been proposed, three I shall cover: <cite>rc.d</cite>, <cite>upstart</cite> and
<cite>systemd</cite>.  Upstart was championed by Ubuntu/Canonical and is an attempt to keep
the simple, file driven approach going.  systemd is however winning hearts and
minds, and has even driven upstart out of the debian world, and so ubuntu will
soon follow suit.  I shall however target 12.04 for the moment and that will
remain upstart based.</p>
<p>rc.d comes from NetBSD, and so is a worthwhile investment in the FreeBSD world.</p>
<div class="section" id="python-and-wsgi">
<h3>Python and WSGI<a class="headerlink" href="#python-and-wsgi" title="Permalink to this headline">¶</a></h3>
<p>Web micro-services will consist mostly of well, web servers.  And in the Python
world that means WSGI.</p>
<p>Now, a WSGI app is a curious beast, essentially it cares nothing for web servers
and threads and so on, it simply takes an <cite>environment</cite> (like CGI env) and a
<cite>start_response</cite> callable.</p>
<p>A WSGI enabled server will wrap the core application (returns &#8220;hello world&#8221;)
in a chain of python functions, each one taking an env and a callable, each one
modifying the response as we go up the chain.</p>
<p>I will have to write a small WSGI server to demonstrate.</p>
<p>Anyway, lets run a WSGI app on FreeBSD</p>
</div>
</div>
<div class="section" id="freebsd">
<h2>FreeBSD<a class="headerlink" href="#freebsd" title="Permalink to this headline">¶</a></h2>
<div class="section" id="overview">
<h3>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h3>
<p>I want to have <em>the simplest possible way to run a micro web service</em>.  For me
this is to make use of the well thought out, well tested and well, simple,
<cite>init</cite> services built into all Unix distributions.</p>
<p>I shall create two dummy web services, <cite>hello.py</cite> that is simply a Flask
service returning &#8220;hello World&#8221;, and this shall be started and stopped
with an <cite>rc.d</cite> script.</p>
<p>A second more complex script shall follow, dealing with some config issues etc.</p>
<p>This is about as simple as it gets (ripped, liberally, from the frontpage of
flask.org.).  However run in the terminal it will respond correctly to the
various signals thrown at it.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>$ python hello.py
 * Running on http://127.0.0.1:5003/
^C

We set the web server running, then can kill it with ctl-C
</pre></div>
</div>
<p>However we want to <em>prove</em> that if the app dies by itself, <cite>rc</cite> will restart it.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>if we run this and then visit localhost:5003/kill,
the process will exit.

(errr... really?)
</pre></div>
</div>
<p>Lets make this &#8220;production-ready&#8221; <a class="footnote-reference" href="#id2" id="id1">[1]</a></p>
<p>THe app factory issue...</p>
</div>
<div class="section" id="using-the-bsd-rc-d-init-approach">
<h3>Using the BSD rc.d init approach<a class="headerlink" href="#using-the-bsd-rc-d-init-approach" title="Permalink to this headline">¶</a></h3>
<p>The short approach is we put a simple .sh script in <cite>/usr/local/etc/rc.d</cite>. This
is called during system init, and it will run a command - that command will be
a WSGI server (like uwsgi / gunicorn / waitress) which will bring up a wsgi app.</p>
<p>This app will serve HTTP happily, but if it falls over, rc.d will restart it.</p>
<p>notes
(test-rc)supervisor-scripts(master)$ which gunicorn
/usr/home/pbrian/venvs/test-rc/bin/gunicorn</p>
<p>Now deploying a simple WSGI app with Gunicorn but what about a djaongo app</p>
</div>
<div class="section" id="django-deployed-standalone-wsgi-with-gunicorn">
<h3>Django deployed standalone WSGI with gunicorn<a class="headerlink" href="#django-deployed-standalone-wsgi-with-gunicorn" title="Permalink to this headline">¶</a></h3>
<div class="highlight-default"><div class="highlight"><pre><span></span>$ gunicorn --pythonpath readthedocs readthedocs.wsgi:application
$ /home/pbrian/venvs/docserver/bin/gunicorn  --pythonpath
/usr/home/pbrian/venvs/docserver/checkouts/readthedocs.org
readthedocs.wsgi:application
</pre></div>
</div>
<p>Have to create a wsgi.py in the readthedocs &#8220;app dir&#8221;</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;DJANGO_SETTINGS_MODULE&quot;</span><span class="p">,</span> <span class="s2">&quot;settings.sqlite&quot;</span><span class="p">)</span>

<span class="c1"># This application object is used by the development server</span>
<span class="c1"># as well as any WSGI server configured to use this file.</span>
<span class="kn">from</span> <span class="nn">django.core.wsgi</span> <span class="k">import</span> <span class="n">get_wsgi_application</span>
<span class="n">application</span> <span class="o">=</span> <span class="n">get_wsgi_application</span><span class="p">()</span>
</pre></div>
</div>
<p>/home/pbrian/venvs/docserver/bin/gunicorn          &#8211;pythonpath
/usr/home/pbrian/venvs/docserver/checkouts/readthedocs.org/readthedocs
wsgi:application</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>rc.d$ cat readthedocs
#!/bin/sh
###
# PROVIDE: readthedocs
# REQUIRE: LOGIN
# KEYWORD: shutdown

# We always require LOGIN unless we know what we are doing.
# shutdown is there to kill us off in case of system shutdown.

. /etc/rc.subr

name=&quot;readthedocs&quot;
rcvar=readthedocs_enable
#pidfile=/tmp/${name}.pid

###########
venv_gunicorn=/home/pbrian/venvs/docserver/bin/gunicorn
django_app_path=/usr/home/pbrian/venvs/docserver/checkouts/readthedocs.org/readthedocs
django_app_wsgi=wsgi:application

command=&quot;$venv_gunicorn -D \
         --pythonpath $django_app_path \
         $django_app_wsgi&quot;

#########

load_rc_config $name
run_rc_command &quot;$1&quot;
</pre></div>
</div>
</div>
</div>
<div class="section" id="bibilio">
<h2>Bibilio<a class="headerlink" href="#bibilio" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><a class="reference external" href="mailto:#pkgng&#37;&#52;&#48;freenode">#pkgng<span>&#64;</span>freenode</a></li>
<li><a class="reference external" href="https://www.freebsd.org/doc/en/articles/rc-scripting/article.html">https://www.freebsd.org/doc/en/articles/rc-scripting/article.html</a></li>
</ul>
<div class="section" id="linux-and-debian">
<h3>Linux and Debian<a class="headerlink" href="#linux-and-debian" title="Permalink to this headline">¶</a></h3>
<p>Well, I used to use <cite>upstart</cite>.  That has been replaced with <cite>systemd</cite> now,
and well, we need to <cite>lose graciously &lt;link to ubuntu post on this&gt;</cite>.</p>
</div>
<div class="section" id="using-systemd">
<h3>Using systemd<a class="headerlink" href="#using-systemd" title="Permalink to this headline">¶</a></h3>
<p>systemd is controversial but it is becoming widespread. It <em>may</em> be over complicted.
For our purposes it is sufficient</p>
<p>We place <em>our</em> unit file in <cite>/etc/systemd/system</cite></p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">Unit</span><span class="p">]</span>
<span class="n">Description</span><span class="o">=</span><span class="n">PaulsTest</span>

<span class="p">[</span><span class="n">Service</span><span class="p">]</span>
<span class="n">ExecStart</span><span class="o">=/</span><span class="n">home</span><span class="o">/</span><span class="n">pbrian</span><span class="o">/</span><span class="n">venvs</span><span class="o">/</span><span class="n">prodwww</span><span class="o">/</span><span class="nb">bin</span><span class="o">/</span><span class="n">python</span> <span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">pbrian</span><span class="o">/</span><span class="n">projects</span><span class="o">/</span><span class="n">mikadoCMS</span><span class="o">/</span><span class="n">mikadocms</span><span class="o">/</span><span class="n">cmsapp</span><span class="o">.</span><span class="n">py</span> <span class="o">--</span><span class="n">config</span><span class="o">=/</span><span class="n">home</span><span class="o">/</span><span class="n">pbrian</span><span class="o">/</span><span class="n">projects</span><span class="o">/</span><span class="n">mikadoCMS</span><span class="o">/</span><span class="n">mikadocms</span><span class="o">/</span><span class="n">data</span><span class="o">/</span><span class="n">mikadosoftware</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">mikado_dev</span><span class="o">.</span><span class="n">ini</span>

<span class="p">[</span><span class="n">Install</span><span class="p">]</span>
<span class="n">WantedBy</span><span class="o">=</span><span class="n">multi</span><span class="o">-</span><span class="n">user</span><span class="o">.</span><span class="n">target</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="further-reading">
<h2>Further reading<a class="headerlink" href="#further-reading" title="Permalink to this headline">¶</a></h2>
<p>(get sphinx to link these up for me ...)</p>
<ul class="simple">
<li>Security for micro-web-services</li>
<li>running your own CA</li>
</ul>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>OK so its not actually production ready - monitoring, logging etc. But its a lot more production than the Flask default server.</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2015, Paul Brian.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.8.
    </div>
  </body>
</html>