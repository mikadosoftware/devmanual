

<!doctype html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Cookies, Testing and security &#8212; TheDevManual 0.0.1 documentation</title>
    
    <link rel="stylesheet" href="../_static/devmanual.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/bizstyle.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="top" title="TheDevManual 0.0.1 documentation" href="../index.html" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <!--[if lt IE 9]>
    <script type="text/javascript" src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
  </head>
  <body role="document">

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="section" id="cookies-testing-and-security">
<h1>Cookies, Testing and security<a class="headerlink" href="#cookies-testing-and-security" title="Permalink to this headline">¶</a></h1>
<hr class="docutils" />
<p>I wish to use a cookie to store a random UUID that represents a server-side
session.  This will then be looked-up server side and the server can trust the
user info gathered (reasonably so)</p>
<p>This works as a useful cut-off point between the authentication system and
everything else.  We can test by sending in a fake session cookie.</p>
<div class="section" id="example">
<h2>Example<a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h2>
<p>If we create a simple wsgi app that just says hello, and returns its environ.</p>
<p>Now we shall write a simple lookup (development only but it will do for now)</p>
<p>Now lets test this.</p>
<p>Here we see we are passing a header of the format desired into the test case.
And the output from the webtest shows that the environ held a cookie of the
right form:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Response</span><span class="p">:</span> <span class="mi">200</span> <span class="n">OK</span>
<span class="n">Content</span><span class="o">-</span><span class="n">Type</span><span class="p">:</span> <span class="n">text</span><span class="o">/</span><span class="n">html</span>
<span class="n">You</span> <span class="n">are</span> <span class="n">user</span> <span class="n">PaulHTTP_COOKIE</span><span class="p">::</span><span class="n">cnxsessionid</span><span class="o">=</span><span class="mi">00000</span>
</pre></div>
</div>
<p>We should use a 2x2 grid to determine responses etc
(TBC)</p>
<div class="section" id="basics">
<h3>Basics<a class="headerlink" href="#basics" title="Permalink to this headline">¶</a></h3>
<p>We do not store sensitive information in a cookie.  Thats not what they are for,
it is totally out of our control and we can never know that the encryption loop
has not been broken <a class="footnote-reference" href="#id2" id="id1">[1]</a></p>
<p>This leaves us with only one option for session cookies - a random number that
is the key to looking up the session details on the server somehow.  Even this
number will need to be in a suiffiociently large space that guessing is
impractical.  And we will need to ensure https traffic end to end to prevent
traffic-sniffing.</p>
<p>So, we shall use a tiered-lookup-cache.  I would expect it to go like this</p>
<ol class="arabic simple">
<li>User GET request to restricted page /secret</li>
<li>User receives 401 auth request, and by some means authenticates</li>
<li>Once authentication is completed, we fire server-side &#8220;after-auth&#8221;</li>
<li>after-auth generates a session<ul>
<li>user_uri, session_starttime, sesssion_endtime, randomUUID</li>
<li>store that in local session cache</li>
<li>set response header for cookie with randomUUID</li>
</ul>
</li>
<li>next request includes sessioncookie<ul>
<li>lookup randomUUID in local session cache</li>
<li>set REMOTE_USER in environ,</li>
</ul>
</li>
<li>scaling - I would only recommend moving to a network local redis style lookup and dropping the local cache - dual cache invalidation for such likely small speed up is foolish</li>
<li>logout<ul>
<li>delete the session details from cache</li>
<li>unset the</li>
<li>add previosu randomUUID to the users <em>already ised list</em>
(this is where the bloom filter may help)</li>
</ul>
</li>
</ol>
</div>
<div class="section" id="onwards-work">
<h3>Onwards work<a class="headerlink" href="#onwards-work" title="Permalink to this headline">¶</a></h3>
<p>The use of sensible cookie handling for sessions is a good thing, however,
there are many many other aspects to a secure system, ranging from acls on the server,</p>
</div>
<div class="section" id="philosophy">
<h3>Philosophy<a class="headerlink" href="#philosophy" title="Permalink to this headline">¶</a></h3>
<p>I want to digress just a little here.  I am not a security researcher and so I
have no special expertese in this area.  However I am trying to minimise the
errors made in a security system, maximise the likelihood that developers (as
opposed to security researchers) will find bugs, and make plain the trade offs
being made.</p>
<p>So, encryption is very very hard to get right even from basic building blocks
like OpenSSH (basically keyczar and nacl are wrappers around such functionality
to prepackage choices of how to put the building blocks together)</p>
<p>I would prefer to thus avoid relying on encryption for a simple reason - I can
easily get it wrong, rely on it being right and never spot my flaws.  In many
other areas I am likely to spot a flaw (oh, look a SQL stmt using string
formatting)</p>
<p>I am making a trade off here - that the cache lookups will not become impossible to manage</p>
</div>
<div class="section" id="bibliography">
<h3>Bibliography<a class="headerlink" href="#bibliography" title="Permalink to this headline">¶</a></h3>
<dl class="docutils">
<dt>Never build unnecessary crypto into your design</dt>
<dd><a class="reference external" href="https://news.ycombinator.com/item?id=4680444">https://news.ycombinator.com/item?id=4680444</a></dd>
<dt>OWASP top 10</dt>
<dd><a class="reference external" href="https://www.owasp.org/index.php/Top_10_2013-T10">https://www.owasp.org/index.php/Top_10_2013-T10</a></dd>
<dt>AES Oracle attacks</dt>
<dd><a class="reference external" href="https://news.ycombinator.com/item?id=1687770">https://news.ycombinator.com/item?id=1687770</a></dd>
</dl>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Encryption loop is my own term. It is <em>very</em> unlikely that the OpenSSH implementation of AES is flawed or explotable.  It is really quite likely that the methods of using AES and setting headers and managing requests and decrypting using a salt stored in a ini file and all the other stuff <em>is</em> flawed, mostly because I wrote it.</td></tr>
</tbody>
</table>
</div>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2015, Paul Brian.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.8.
    </div>
  </body>
</html>