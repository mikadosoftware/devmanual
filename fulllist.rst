Modern Capabilities 
-------------------
This is the set of *capabilities* a modern Software team should have. Few need to be core competencies, but all need to be capable.

esprit de corps
---------------
Teams matter waaaay more than individual contributors

No one likes being told what to do.  So let developers contribute their next best step.

Discuss planning carefully, have wide open discussions on next step.  Lieutenants own chunks of code. Use Linux development model 

At the beginning of greenfield almost any code laid down is 10x. Don't believe in 10x myth.  Iceland and Wales versus England.  Esprit de corp

Social organisation, commit bits, licenses and future income and reputation.
-----


Start with the Dashboard
------------------------
This gives us a simple means to always show we have a feedback loop and always remain in control.  It is also the simplest means to show what is provided for the end user.


The CTO Dashboard
-----------------

For every software organisation we can define a set of capabilities, and for each capability we can define best practise and then rate our own organisation against the best practise.  This can give a clear idea where to focus improvement efforts.

Team capabilities
-----------------

- 

- micro-services architecture



Organisation capabilities
-------------------------

- flexible cell structure ?

Business capabilities
---------------------

- programmable corporation


- Deploy
- Develop
- Release 
- monitor
- operations (SOP)
- security
- service levels (SLA)
- ticket requests
- architecture / distributed data
- programmable corporation 
- adjusting business model
- marketing
- disaster recovery / option pricing
- learning and training and teamwork
- stakeholder engagement

Capabilities
------------

* Deployment can deploy code through promotion of fixed "builds" into production using totally automated means.

* micro services architecture
  This is a major issue. Includes security, service discovery messaging logging and pr nose to only go through front door. See stevey blog post.

* OS installation and Hardening
  Choice of OS, location
  Ansible or similar automation scripts

* Kerberos and Authentication
  Authentication and Authorisation are vital capabilities and federated, distributed security have so many advantages (think uUId as primary key )
  
* Build promotion and use of containers
  PyHolodeck 

* message queues and worker pools
  Messaging
  Job scheduling based on events and then queues
  Is a resource problem always

* performance monitoring
  metrics gathering with graphite

* unit testing, integration testing, perfromance testing

* user acceptanbce tests and UI tests
  Automated testing is vital and we must put huge amounts of effort into it simply to make the next release
  
* continuous integrations and delivery
  There is no point batching up changes to go on a time based schedule. Code is ready as it is written and the decision to release should be based on automated tests. Only marketing or other business decisions should delay - so always push to pre-prod 
  
* pre-prod is live-clone

* replaying actual traffic
  
* Reporting
  Simple reports

* SOPs and checklists

* Measuring metrics

* documentation

* Dev Ops

* statistics

* distributed data and computation
  Use of Apache spark, Hadoop etc

* Javascript

* Angular vs Jquery

* Programmable Corporation

* functional programming and scalability
  Elixr and OTP

* bug tracking, code analysis,

* git and git workflow

* Linux and workstations

* Mobile development

* Big Data

* Maturity and keeping on a single course

* seven league boots

* earthquake-let theory of software development. Building blocks not planned features 

* Work harder on fewer projects and polish them to be CV-worthy shipping working software

* Message Queue

* Business Intelligence reporting

* Software KPIs, buisness KPIs

* Simple Marketing (Twilio approach), SEO

* Debugging tools
  CHarles proxy
  Chrome debugger

* Web technologies (html 5)
  Bootstrap, HTML 5, cimples CSS

* Rekational Databases

* NOSQL databases

* Storage systems

* Backup and recovery
  Business Disaster recovery and assurance
  Multiple data centres

* Time, Unicode, basic data types

* serialisation
  pickle, json etc

* Cacheing

* Configuration basics

* command line is all

* Publishing own work

* contact management

* email management

* Practise on smaller complete projects

* jenkins

* chatbots and IRC. Team comms. Choose one one o said one!! 

* erlang

* rethinkdb
 

Systems Infrastructure
----------------------

Storage
-------

Front end
---------

Middleware
----------

Storage
-------

Disaster Recovery
-----------------

Distributed computing vs redundant
----------------------------------

SOA and API design
------------------

Project management
------------------

Debugging
---------

KISS
----

Slow Development, manageable infrastructure
-------------------------------------------


NOSQL
-----

Statistics
----------

Seven league Boots
------------------

Statistics
ML
NLP
CV


Why full stack matters, and why you cant do it all
---------------------------------------------------




* Project Management
  history of Agile and scrum
  Critique of Agile / SCrum
     " You dont have to sprint if you are making seven-league boots"
  Essential project management
  Tight co-ordination with team members
  Mostly the same capabilities - but teamwork, transfer of trust.
  Read that book quoted by Clinton Roshenm

* Specfication discovery
  Working with users
  See service lifecycle - whats the User Need?

* build everything as a service
  Gov.uk service manaual
  SOA
  history of SOA in Amazon

* Managing tickets and commits
  Use of source cntrol
  Use of ticketing system

* specifications, design and tickets
  Must do upfront design.
  Design / discussion documents are vital and allow clarification
  Call this Architecture if you like, but dont assume people understand

* Everything is a service
  So services have Interface Points and lifecycles.

* 



Project mgmt
------------

We all work on projects of some form or other.  Tools will help us.
Working for an enterprise, they want different reporting approaches.
So the simplest answer is to have a buffer - write and read to and from

Tickets in a parent child chain
A child can have many parents (?)
Git based bugs?
Functional specs that map easily to tickets (spec2ticket)
Unless you write down explicitly what you are trying to achieve, and discuss it with the developers and business owners, you end up with three things - some people who don't understand most of it and just go along hoping to pick it up later, some people who think they understand it but have forgotten some vital and really hard parts and think this is going to be easy, and some people who think they are building something not quite the same shape as everyone else.

The mark of a high functioning team is how quickly new hires get up to speed - you don't need Einstein to come in if you kept it simple and well tested and well API'd.

Discover, write up and do OSS projects on
Scale up to 1000 cloud instances with full deployment and development and monitoring process

Server to server authentication


"Full on Full Stack"

What does it really take to be a full stack developer?

-


Intelligence gathering :
- economy model etc

Security as a baked in goal

We are aiming for a level of security that is good but not awesome.

This is where the internal threat is minimal  and external threat is high - we protect against threats with high external component and lower internal.

Internal is best to use a lot lot of audit

- server to server authentication
 

Skills required (bold=essential)
·         FreeIPA/LDAP
·         Ubuntu/Redhat/CentOS
·         VMware (candidate does not have to be a specialist, but ability to spin up VMs)
·         Configuration management (Ansible desirable but can demonstrate familiarity with others such puppet and chef)
·         Scripting - shell/php/python
·         mysql
·         apache
·         HA-Proxy / load balancing (both desirable)
·         High availability (Keepalived) (desirable)
·         Change control (exposure/demonstration of working in a controlled environment)
·         Source code control (git)
·         monitoring (solarwinds/nagios)
·         system hardening and security
·         iptables (desirable)
·         open source software
·         DNS/DHCP
